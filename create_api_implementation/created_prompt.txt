
I have a set of tools that I use to interact with a DB in a json format. These tools allow me to perform various operations such as creating, reading, updating, and deleting records in the database. Those tools are functions that take parameters and return a value in json format.
Your task is to create for me the tools. Each tool is a class that comprises of two functions: one for the implementation of the tool and another for the schema of the tool. The implementation function should return a json string that represents the result of the operation, while the schema function should return a dictionary that describes the parameters and their types. The schema function should also include a description of the tool and its parameters. I will provide you with examples of tools with their implementations and schemas, and you should use them as a reference to create your own tools. Also, I will provide the database schema for you to use as a reference for the parameters and their types.

# Database schema:
CREATE TABLE `users` (
  `user_id` int PRIMARY KEY,
  `first_name` varchar(100) NOT NULL,
  `last_name` varchar(100) NOT NULL,
  `email` varchar(320) UNIQUE NOT NULL,
  `role` enum(admin,employee) NOT NULL,
  `timezone` varchar(50) NOT NULL,
  `status` enum(active,inactive,suspended) NOT NULL DEFAULT 'active',
  `created_at` timestamp NOT NULL DEFAULT (NOW()),
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `funds` (
  `fund_id` int PRIMARY KEY,
  `name` varchar(255) NOT NULL,
  `fund_type` enum(equity,fixed_income,multi_asset,hedge) NOT NULL,
  `base_currency` enum(USD,EUR,GBP,NGN) NOT NULL,
  `manager_id` int NOT NULL,
  `size` decimal(18,2),
  `status` enum(open,closed) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW()),
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `investors` (
  `investor_id` int PRIMARY KEY,
  `employee_id` int NOT NULL,
  `name` varchar(255) NOT NULL,
  `investor_type` enum(organization,retail,high_net_worth) NOT NULL,
  `contact_email` varchar(320) NOT NULL,
  `accreditation_status` enum(accredited,non_accredited) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `subscriptions` (
  `subscription_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `investor_id` int NOT NULL,
  `amount` decimal(18,2) NOT NULL,
  `currency` enum(USD,EUR,GBP,NGN) NOT NULL,
  `status` enum(pending,approved,cancelled) NOT NULL,
  `request_assigned_to` int NOT NULL,
  `request_date` date NOT NULL,
  `approval_date` date,
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `commitments` (
  `commitment_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `investor_id` int NOT NULL,
  `commitment_amount` decimal(18,2) NOT NULL,
  `currency` enum(USD,EUR,GBP,NGN) NOT NULL,
  `commitment_date` date NOT NULL,
  `status` enum(pending,fulfilled) NOT NULL,
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `portfolios` (
  `portfolio_id` int PRIMARY KEY,
  `investor_id` int NOT NULL,
  `base_currency` enum(USD,EUR,GBP,NGN) NOT NULL,
  `status` enum(active,inactive,archived) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW()),
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `portfolio_holdings` (
  `holding_id` int PRIMARY KEY,
  `portfolio_id` int NOT NULL,
  `instrument_id` int NOT NULL,
  `quantity` decimal(18,4) NOT NULL,
  `cost_basis` decimal(18,4) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `instruments` (
  `instrument_id` int PRIMARY KEY,
  `ticker` varchar(20) UNIQUE NOT NULL,
  `name` varchar(255) NOT NULL,
  `instrument_type` enum(stock,bond,derivative,cash,other) NOT NULL
);

CREATE TABLE `instrument_prices` (
  `price_id` int PRIMARY KEY,
  `instrument_id` int NOT NULL,
  `price_date` date NOT NULL,
  `open_price` decimal(18,4) NOT NULL,
  `high_price` decimal(18,4) NOT NULL,
  `low_price` decimal(18,4) NOT NULL,
  `close_price` decimal(18,4) NOT NULL
);

CREATE TABLE `nav_records` (
  `nav_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `nav_date` date NOT NULL,
  `nav_value` decimal(18,4) NOT NULL,
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `trades` (
  `trade_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `instrument_id` int NOT NULL,
  `trade_date` timestamp NOT NULL,
  `quantity` decimal(18,4) NOT NULL,
  `price` decimal(18,4) NOT NULL,
  `side` enum(buy,sell) NOT NULL,
  `status` enum(executed,pending,failed) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `notifications` (
  `notification_id` int PRIMARY KEY,
  `email` varchar(320),
  `type` enum(alert,report,reminder,subscription_update) NOT NULL,
  `class` enum(funds,investors,portfolios,trades,invoices,reports,documents,subscriptions,commitments) NOT NULL,
  `reference_id` int,
  `status` enum(pending,sent,failed) NOT NULL,
  `sent_at` timestamp,
  `created_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `reports` (
  `report_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `investor_id` int,
  `report_date` date NOT NULL,
  `report_type` enum(performance,holding,financial) NOT NULL DEFAULT 'performance',
  `generated_by` int NOT NULL,
  `status` enum(pending,completed,failed) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW()),
  `export_period_end` date NOT NULL
);

CREATE TABLE `documents` (
  `document_id` int PRIMARY KEY,
  `name` varchar(255) NOT NULL,
  `type` enum(pdf,xlsx,docx,csv,other) NOT NULL,
  `uploaded_by` int NOT NULL,
  `upload_date` timestamp NOT NULL,
  `report_id` int,
  `size_bytes` bigint,
  `status` enum(available,archived,deleted) NOT NULL
);

CREATE TABLE `invoices` (
  `invoice_id` int PRIMARY KEY,
  `fund_id` int NOT NULL,
  `investor_id` int NOT NULL,
  `commitment_id` int,
  `invoice_date` date NOT NULL,
  `due_date` date NOT NULL,
  `amount` decimal(18,2) NOT NULL,
  `payment_type` enum(auto-pay,manual) NOT NULL DEFAULT 'manual',
  `currency` enum(USD,EUR,GBP,NGN) NOT NULL,
  `status` enum(issued,paid) NOT NULL,
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `payments` (
  `payment_id` int PRIMARY KEY,
  `invoice_id` int NOT NULL,
  `payment_date` timestamp NOT NULL,
  `amount` decimal(18,2) NOT NULL,
  `payment_method` enum(wire,cheque,credit_card,bank_transfer) NOT NULL,
  `status` enum(draft,completed,failed) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT (NOW())
);

CREATE TABLE `tickets` (
  `ticket_id` int PRIMARY KEY,
  `invoice_id` int,
  `issue_date` timestamp NOT NULL,
  `type` enum(missing_payment,overpayment,underpayment,mismatched_amount,invoice_duplicate,manual_follow_up),
  `status` enum(open,in_review,resolved,closed) NOT NULL,
  `assigned_to` int,
  `resolution_date` timestamp,
  `created_at` timestamp NOT NULL DEFAULT (NOW()),
  `updated_at` timestamp NOT NULL DEFAULT (NOW())
);

ALTER TABLE `funds` ADD FOREIGN KEY (`manager_id`) REFERENCES `users` (`user_id`);

ALTER TABLE `reports` ADD FOREIGN KEY (`generated_by`) REFERENCES `users` (`user_id`);

ALTER TABLE `documents` ADD FOREIGN KEY (`uploaded_by`) REFERENCES `users` (`user_id`);

ALTER TABLE `tickets` ADD FOREIGN KEY (`assigned_to`) REFERENCES `users` (`user_id`);

ALTER TABLE `subscriptions` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `commitments` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `nav_records` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `trades` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `reports` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `invoices` ADD FOREIGN KEY (`fund_id`) REFERENCES `funds` (`fund_id`);

ALTER TABLE `subscriptions` ADD FOREIGN KEY (`investor_id`) REFERENCES `investors` (`investor_id`);

ALTER TABLE `commitments` ADD FOREIGN KEY (`investor_id`) REFERENCES `investors` (`investor_id`);

ALTER TABLE `portfolios` ADD FOREIGN KEY (`investor_id`) REFERENCES `investors` (`investor_id`);

ALTER TABLE `invoices` ADD FOREIGN KEY (`investor_id`) REFERENCES `investors` (`investor_id`);

ALTER TABLE `portfolio_holdings` ADD FOREIGN KEY (`portfolio_id`) REFERENCES `portfolios` (`portfolio_id`);

ALTER TABLE `portfolio_holdings` ADD FOREIGN KEY (`instrument_id`) REFERENCES `instruments` (`instrument_id`);

ALTER TABLE `instrument_prices` ADD FOREIGN KEY (`instrument_id`) REFERENCES `instruments` (`instrument_id`);

ALTER TABLE `trades` ADD FOREIGN KEY (`instrument_id`) REFERENCES `instruments` (`instrument_id`);

ALTER TABLE `payments` ADD FOREIGN KEY (`invoice_id`) REFERENCES `invoices` (`invoice_id`);

ALTER TABLE `tickets` ADD FOREIGN KEY (`invoice_id`) REFERENCES `invoices` (`invoice_id`);

ALTER TABLE `subscriptions` ADD FOREIGN KEY (`request_assigned_to`) REFERENCES `users` (`user_id`);

ALTER TABLE `invoices` ADD FOREIGN KEY (`commitment_id`) REFERENCES `commitments` (`commitment_id`);

ALTER TABLE `investors` ADD FOREIGN KEY (`employee_id`) REFERENCES `users` (`user_id`);

ALTER TABLE `documents` ADD FOREIGN KEY (`report_id`) REFERENCES `reports` (`report_id`);


# Examples of a tool implementation and schema:
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class AddIncidentComment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], incident_id: str, user_id: str, 
               comment_text: str, is_public: bool = True) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        incidents = data.get("incidents", {})
        users = data.get("users", {})
        comments = data.get("incident_comments", {})
        
        # Validate incident exists
        if str(incident_id) not in incidents:
            raise ValueError(f"Incident {incident_id} not found")
        
        # Validate user exists
        if str(user_id) not in users:
            raise ValueError(f"User {user_id} not found")
        
        comment_id = generate_id(comments)
        timestamp = "2025-10-01T00:00:00"
        
        new_comment = {
            "incident_comment_id": comment_id,
            "incident_id": incident_id,
            "user_id": user_id,
            "comment_text": comment_text,
            "is_public": is_public,
            "created_at": timestamp,
            "updated_at": timestamp
        }
        
        comments[str(comment_id)] = new_comment
        return json.dumps(new_comment)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "add_incident_comment",
                "description": "Add a comment to an incident",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "incident_id": {"type": "string", "description": "ID of the incident"},
                        "user_id": {"type": "string", "description": "ID of the user adding the comment"},
                        "comment_text": {"type": "string", "description": "Text of the comment"},
                        "is_public": {"type": "boolean", "description": "Whether the comment is public or private"}
                    },
                    "required": ["incident_id", "user_id", "comment_text"]
                }
            }
        }


import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateIncidentTask(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], incident_id: str, description: str,
               assigned_to: str, priority: str = "medium", 
               due_date: Optional[str] = None, status: str = "todo") -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        incidents = data.get("incidents", {})
        users = data.get("users", {})
        tasks = data.get("tasks", {})
        
        # Validate incident exists
        if str(incident_id) not in incidents:
            raise ValueError(f"Incident {incident_id} not found")
        
        # Validate assigned user exists
        if str(assigned_to) not in users:
            raise ValueError(f"Assigned user {assigned_to} not found")
        
        # Validate priority
        valid_priorities = ["low", "medium", "high", "critical"]
        if priority not in valid_priorities:
            raise ValueError(f"Invalid priority. Must be one of {valid_priorities}")
        
        # Validate status
        valid_statuses = ["todo", "in_progress", "blocked", "done", "cancelled"]
        if status not in valid_statuses:
            raise ValueError(f"Invalid status. Must be one of {valid_statuses}")
        
        task_id = generate_id(tasks)
        timestamp = "2025-10-01T00:00:00"
        
        new_task = {
            "task_id": task_id,
            "incident_id": incident_id,
            "description": description,
            "assigned_to": assigned_to,
            "status": status,
            "priority": priority,
            "due_date": due_date,
            "created_at": timestamp,
            "updated_at": timestamp
        }
        
        tasks[str(task_id)] = new_task
        return json.dumps({"task_id": task_id})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_incident_task",
                "description": "Create a new task for an incident",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "incident_id": {"type": "string", "description": "ID of the incident"},
                        "description": {"type": "string", "description": "Task description"},
                        "assigned_to": {"type": "string", "description": "ID of the user assigned to the task"},
                        "priority": {"type": "string", "description": "Task priority (low, medium, high, critical), defaults to medium"},
                        "due_date": {"type": "string", "description": "Due date in ISO format (optional)"},
                        "status": {"type": "string", "description": "Task status (todo, in_progress, blocked, done, cancelled), defaults to todo"}
                    },
                    "required": ["incident_id", "description", "assigned_to"]
                }
            }
        }


import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GetIncidentTasks(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], incident_id: int, assigned_to: Optional[int] = None,
               status: Optional[str] = None) -> str:
        tasks = data.get("tasks", {})
        results = []
        
        for task in tasks.values():
            if task.get("incident_id") != incident_id:
                continue
            if assigned_to and task.get("assigned_to") != assigned_to:
                continue
            if status and task.get("status") != status:
                continue
            results.append(task)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_incident_tasks",
                "description": "Get tasks for a specific incident",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "incident_id": {"type": "integer", "description": "ID of the incident"},
                        "assigned_to": {"type": "integer", "description": "Filter by assigned user ID"},
                        "status": {"type": "string", "description": "Filter by task status (todo, in_progress, blocked, done, cancelled)"}
                    },
                    "required": ["incident_id"]
                }
            }
        }

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class SearchUsers(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], company_id: Optional[str] = None, 
               department_id: Optional[str] = None, role: Optional[str] = None,
               status: Optional[str] = None, email: Optional[str] = None) -> str:
        users = data.get("users", {})
        results = []
        
        for user in users.values():
            if company_id and user.get("company_id") != company_id:
                continue
            if department_id and user.get("department_id") != department_id:
                continue
            if role and user.get("role") != role:
                continue
            if status and user.get("status") != status:
                continue
            if email and user.get("email", "").lower() != email.lower():
                continue
            results.append(user)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "search_users",
                "description": "Search users with optional filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "company_id": {"type": "string", "description": "Filter by company ID"},
                        "department_id": {"type": "string", "description": "Filter by department ID"},
                        "role": {"type": "string", "description": "Filter by role (end_user, agent, manager, admin)"},
                        "status": {"type": "string", "description": "Filter by status (active, inactive)"},
                        "email": {"type": "string", "description": "Filter by email address"}
                    },
                    "required": []
                }
            }
        }

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class LinkIncidentToKb(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], incident_id: str, knowledge_base_id: str) -> str:
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        incidents = data.get("incidents", {})
        kb_articles = data.get("knowledge_base", {})
        incident_knowledge = data.get("incident_knowledge", {})
        
        # Validate incident exists
        if str(incident_id) not in incidents:
            raise ValueError(f"Incident {incident_id} not found")
        
        # Validate KB article exists
        if str(knowledge_base_id) not in kb_articles:
            raise ValueError(f"Knowledge base article {knowledge_base_id} not found")
        
        # Check if link already exists
        for link in incident_knowledge.values():
            if (link.get("incident_id") == incident_id and 
                link.get("knowledge_base_id") == knowledge_base_id):
                return json.dumps({"status": "already_linked"})
        
        link_id = generate_id(incident_knowledge)
        timestamp = "2025-10-01T00:00:00"
        
        new_link = {
            "incident_id": incident_id,
            "knowledge_base_id": knowledge_base_id,
            "created_at": timestamp
        }
        
        incident_knowledge[str(link_id)] = new_link
        return json.dumps(new_link)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "link_incident_to_kb",
                "description": "Link an incident to a knowledge base article",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "incident_id": {"type": "string", "description": "ID of the incident"},
                        "knowledge_base_id": {"type": "string", "description": "ID of the knowledge base article"}
                    },
                    "required": ["incident_id", "knowledge_base_id"]
                }
            }
        }

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class SearchDepartments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], company_id: Optional[str] = None, 
               manager_id: Optional[str] = None, name: Optional[str] = None) -> str:
        departments = data.get("departments", {})
        results = []
        
        for department in departments.values():
            if company_id and department.get("company_id") != company_id:
                continue
            if manager_id and department.get("manager_id") != manager_id:
                continue
            if name and name.lower() not in department.get("name", "").lower():
                continue
            results.append(department)
        
        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "search_departments",
                "description": "Retrieves departments that match the specified filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "company_id": {"type": "string", "description": "Filter by company ID"},
                        "manager_id": {"type": "string", "description": "Filter by manager ID"},
                        "name": {"type": "string", "description": "Filter by department name (partial match)"}
                    },
                    "required": []
                }
            }
        }

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class QueryIncidentSLAs(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], company_id, incident_id: Optional[str] = None,
               sla_id: Optional[str] = None, status: Optional[str] = None) -> str:
        incident_slas = data.get("incident_sla", {})
        incidents = data.get("incidents", {})
        company_incidents_ids = [incident_k for incident_k, incident_v in incidents.items() if incident_v.get("company_id") == company_id]
        results = []

        if not company_incidents_ids:
            return json.dumps(results)

        
        for sla in incident_slas.values():
            if sla_id and sla.get("sla_id") != sla_id:
                continue

            if sla.get("incident_id") not in company_incidents_ids:
                continue

            if incident_id and (sla.get("incident_id") != incident_id or sla.get("incident_id") not in company_incidents_ids):
                # print(f"Skipping SLA {sla.get('sla_id')} for incident {sla.get('incident_id')}, not in company {company_id}")
                # print(f"Incident IDs in company {company_id}: {company_incidents_ids}")
                continue
            
            if sla_id and sla.get("sla_id") != sla_id:
                continue
            
            if sla.get("status") and status and sla.get("status") != status:
                continue
            
            results.append(sla)


        return json.dumps(results)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "query_incident_slas",
                "description": "Fetch incident SLAs of a company with optional filters",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "company_id": {"type": "string", "description": "Filter by company ID"},
                        "incident_id": {"type": "string", "description": "Filter by incident ID"},
                        "sla_id": {"type": "string", "description": "Filter by SLA policy ID"},
                        "status": {"type": "string", "description": "Filter by status (Pending, Completed, Cancelled)"}
                    },
                    "required": ["company_id"]
                }
            }
        }


# Required tools:

AddNewHolding
Arguments: portfolio_id, instrument_id, quantity, cost_basis
Returns: Holding

DeleteHolding
Arguments: holding_id
Returns: Holding

AddPayment
Arguments: invoice_id, payment_date, amount, payment_method
Returns: Payment

UpdateInstrument
Arguments: instrument_id, ticker, name, instrument_type
Returns: Instrument

UpdateInstrumentPrice
Arguments: price_id, open_price, high_price, low_price, close_price
Returns: InstrumentPrice

UpdateReport
Arguments: report_id, status
Returns: Report

EmailUser
Arguments: user_id, class, reference_id
Returns: Notification

Please create the tools based on the examples and the database schema. 

Notes: 
- assign this timestamp to the created_at and updated_at fields: "2025-10-01T00:00:00ZZ".
- All IDs are strings, not integers.
- Use the generate_id function to generate unique IDs for the records.
- Each tool should have its own imports and utility functions without being shared across tools.
- The tools should be implemented in a way that they can be used independently.

Your generated tools should be in a bash script that can be executed to create them in files that hold the same name as the class name. Each file should contain the class definition and its methods. The files should be named as follows: {tool_name}.py, where {tool_name} is the name of the tool class. Take care that all names should be in snake_case format.
    